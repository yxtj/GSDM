// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class Arg;
class Args;
class ConfigData;
class FileParams;
class Record;
class Records;

enum CompressionFormat {
  NONE = 0,
  LZO = 1,
  ZLIB = 2
};
bool CompressionFormat_IsValid(int value);
const CompressionFormat CompressionFormat_MIN = NONE;
const CompressionFormat CompressionFormat_MAX = ZLIB;
const int CompressionFormat_ARRAYSIZE = CompressionFormat_MAX + 1;

// ===================================================================

class Arg : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Arg) */ {
 public:
  Arg();
  virtual ~Arg();

  Arg(const Arg& from);

  inline Arg& operator=(const Arg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Arg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Arg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Arg* other);

  // implements Message ----------------------------------------------

  inline Arg* New() const { return New(NULL); }

  Arg* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Arg& from);
  void MergeFrom(const Arg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Arg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required bytes value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Arg)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Arg* default_instance_;
};
// -------------------------------------------------------------------

class Args : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Args) */ {
 public:
  Args();
  virtual ~Args();

  Args(const Args& from);

  inline Args& operator=(const Args& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Args& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Args* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Args* other);

  // implements Message ----------------------------------------------

  inline Args* New() const { return New(NULL); }

  Args* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Args& from);
  void MergeFrom(const Args& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Args* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Arg param = 1;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 1;
  const ::Arg& param(int index) const;
  ::Arg* mutable_param(int index);
  ::Arg* add_param();
  ::google::protobuf::RepeatedPtrField< ::Arg >*
      mutable_param();
  const ::google::protobuf::RepeatedPtrField< ::Arg >&
      param() const;

  // @@protoc_insertion_point(class_scope:Args)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Arg > param_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Args* default_instance_;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Record) */ {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Record& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Record* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Record* other);

  // implements Message ----------------------------------------------

  inline Record* New() const { return New(NULL); }

  Record* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required bytes value1 = 2;
  bool has_value1() const;
  void clear_value1();
  static const int kValue1FieldNumber = 2;
  const ::std::string& value1() const;
  void set_value1(const ::std::string& value);
  void set_value1(const char* value);
  void set_value1(const void* value, size_t size);
  ::std::string* mutable_value1();
  ::std::string* release_value1();
  void set_allocated_value1(::std::string* value1);

  // required bytes value2 = 3;
  bool has_value2() const;
  void clear_value2();
  static const int kValue2FieldNumber = 3;
  const ::std::string& value2() const;
  void set_value2(const ::std::string& value);
  void set_value2(const char* value);
  void set_value2(const void* value, size_t size);
  ::std::string* mutable_value2();
  ::std::string* release_value2();
  void set_allocated_value2(::std::string* value2);

  // required bytes value3 = 4;
  bool has_value3() const;
  void clear_value3();
  static const int kValue3FieldNumber = 4;
  const ::std::string& value3() const;
  void set_value3(const ::std::string& value);
  void set_value3(const char* value);
  void set_value3(const void* value, size_t size);
  ::std::string* mutable_value3();
  ::std::string* release_value3();
  void set_allocated_value3(::std::string* value3);

  // @@protoc_insertion_point(class_scope:Record)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_value3();
  inline void clear_has_value3();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value1_;
  ::google::protobuf::internal::ArenaStringPtr value2_;
  ::google::protobuf::internal::ArenaStringPtr value3_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Record* default_instance_;
};
// -------------------------------------------------------------------

class Records : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Records) */ {
 public:
  Records();
  virtual ~Records();

  Records(const Records& from);

  inline Records& operator=(const Records& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Records& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Records* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Records* other);

  // implements Message ----------------------------------------------

  inline Records* New() const { return New(NULL); }

  Records* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Records& from);
  void MergeFrom(const Records& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Records* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Record param = 1;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 1;
  const ::Record& param(int index) const;
  ::Record* mutable_param(int index);
  ::Record* add_param();
  ::google::protobuf::RepeatedPtrField< ::Record >*
      mutable_param();
  const ::google::protobuf::RepeatedPtrField< ::Record >&
      param() const;

  // @@protoc_insertion_point(class_scope:Records)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Record > param_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Records* default_instance_;
};
// -------------------------------------------------------------------

class FileParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:FileParams) */ {
 public:
  FileParams();
  virtual ~FileParams();

  FileParams(const FileParams& from);

  inline FileParams& operator=(const FileParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FileParams& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileParams* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileParams* other);

  // implements Message ----------------------------------------------

  inline FileParams* New() const { return New(NULL); }

  FileParams* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileParams& from);
  void MergeFrom(const FileParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Arg attr = 1;
  int attr_size() const;
  void clear_attr();
  static const int kAttrFieldNumber = 1;
  const ::Arg& attr(int index) const;
  ::Arg* mutable_attr(int index);
  ::Arg* add_attr();
  ::google::protobuf::RepeatedPtrField< ::Arg >*
      mutable_attr();
  const ::google::protobuf::RepeatedPtrField< ::Arg >&
      attr() const;

  // optional int32 compression = 2 [default = 0];
  bool has_compression() const;
  void clear_compression();
  static const int kCompressionFieldNumber = 2;
  ::google::protobuf::int32 compression() const;
  void set_compression(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FileParams)
 private:
  inline void set_has_compression();
  inline void clear_has_compression();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Arg > attr_;
  ::google::protobuf::int32 compression_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static FileParams* default_instance_;
};
// -------------------------------------------------------------------

class ConfigData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ConfigData) */ {
 public:
  ConfigData();
  virtual ~ConfigData();

  ConfigData(const ConfigData& from);

  inline ConfigData& operator=(const ConfigData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ConfigData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigData* other);

  // implements Message ----------------------------------------------

  inline ConfigData* New() const { return New(NULL); }

  ConfigData* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigData& from);
  void MergeFrom(const ConfigData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 num_workers = 1;
  bool has_num_workers() const;
  void clear_num_workers();
  static const int kNumWorkersFieldNumber = 1;
  ::google::protobuf::int32 num_workers() const;
  void set_num_workers(::google::protobuf::int32 value);

  // required int32 worker_id = 2;
  bool has_worker_id() const;
  void clear_worker_id();
  static const int kWorkerIdFieldNumber = 2;
  ::google::protobuf::int32 worker_id() const;
  void set_worker_id(::google::protobuf::int32 value);

  // required int32 master_id = 3;
  bool has_master_id() const;
  void clear_master_id();
  static const int kMasterIdFieldNumber = 3;
  ::google::protobuf::int32 master_id() const;
  void set_master_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ConfigData)
 private:
  inline void set_has_num_workers();
  inline void clear_has_num_workers();
  inline void set_has_worker_id();
  inline void clear_has_worker_id();
  inline void set_has_master_id();
  inline void clear_has_master_id();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 num_workers_;
  ::google::protobuf::int32 worker_id_;
  ::google::protobuf::int32 master_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ConfigData* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Arg

// required bytes key = 1;
inline bool Arg::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Arg::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Arg::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Arg::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Arg::key() const {
  // @@protoc_insertion_point(field_get:Arg.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Arg::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Arg.key)
}
inline void Arg::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Arg.key)
}
inline void Arg::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Arg.key)
}
inline ::std::string* Arg::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:Arg.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Arg::release_key() {
  // @@protoc_insertion_point(field_release:Arg.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Arg::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Arg.key)
}

// required bytes value = 2;
inline bool Arg::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Arg::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Arg::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Arg::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Arg::value() const {
  // @@protoc_insertion_point(field_get:Arg.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Arg::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Arg.value)
}
inline void Arg::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Arg.value)
}
inline void Arg::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Arg.value)
}
inline ::std::string* Arg::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:Arg.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Arg::release_value() {
  // @@protoc_insertion_point(field_release:Arg.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Arg::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Arg.value)
}

// -------------------------------------------------------------------

// Args

// repeated .Arg param = 1;
inline int Args::param_size() const {
  return param_.size();
}
inline void Args::clear_param() {
  param_.Clear();
}
inline const ::Arg& Args::param(int index) const {
  // @@protoc_insertion_point(field_get:Args.param)
  return param_.Get(index);
}
inline ::Arg* Args::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Args.param)
  return param_.Mutable(index);
}
inline ::Arg* Args::add_param() {
  // @@protoc_insertion_point(field_add:Args.param)
  return param_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Arg >*
Args::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Args.param)
  return &param_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Arg >&
Args::param() const {
  // @@protoc_insertion_point(field_list:Args.param)
  return param_;
}

// -------------------------------------------------------------------

// Record

// required bytes key = 1;
inline bool Record::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Record::key() const {
  // @@protoc_insertion_point(field_get:Record.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Record.key)
}
inline void Record::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Record.key)
}
inline void Record::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Record.key)
}
inline ::std::string* Record::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:Record.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Record::release_key() {
  // @@protoc_insertion_point(field_release:Record.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Record.key)
}

// required bytes value1 = 2;
inline bool Record::has_value1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record::set_has_value1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record::clear_has_value1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record::clear_value1() {
  value1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value1();
}
inline const ::std::string& Record::value1() const {
  // @@protoc_insertion_point(field_get:Record.value1)
  return value1_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_value1(const ::std::string& value) {
  set_has_value1();
  value1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Record.value1)
}
inline void Record::set_value1(const char* value) {
  set_has_value1();
  value1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Record.value1)
}
inline void Record::set_value1(const void* value, size_t size) {
  set_has_value1();
  value1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Record.value1)
}
inline ::std::string* Record::mutable_value1() {
  set_has_value1();
  // @@protoc_insertion_point(field_mutable:Record.value1)
  return value1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Record::release_value1() {
  // @@protoc_insertion_point(field_release:Record.value1)
  clear_has_value1();
  return value1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_allocated_value1(::std::string* value1) {
  if (value1 != NULL) {
    set_has_value1();
  } else {
    clear_has_value1();
  }
  value1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value1);
  // @@protoc_insertion_point(field_set_allocated:Record.value1)
}

// required bytes value2 = 3;
inline bool Record::has_value2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record::set_has_value2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record::clear_has_value2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record::clear_value2() {
  value2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value2();
}
inline const ::std::string& Record::value2() const {
  // @@protoc_insertion_point(field_get:Record.value2)
  return value2_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_value2(const ::std::string& value) {
  set_has_value2();
  value2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Record.value2)
}
inline void Record::set_value2(const char* value) {
  set_has_value2();
  value2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Record.value2)
}
inline void Record::set_value2(const void* value, size_t size) {
  set_has_value2();
  value2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Record.value2)
}
inline ::std::string* Record::mutable_value2() {
  set_has_value2();
  // @@protoc_insertion_point(field_mutable:Record.value2)
  return value2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Record::release_value2() {
  // @@protoc_insertion_point(field_release:Record.value2)
  clear_has_value2();
  return value2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_allocated_value2(::std::string* value2) {
  if (value2 != NULL) {
    set_has_value2();
  } else {
    clear_has_value2();
  }
  value2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value2);
  // @@protoc_insertion_point(field_set_allocated:Record.value2)
}

// required bytes value3 = 4;
inline bool Record::has_value3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Record::set_has_value3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Record::clear_has_value3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Record::clear_value3() {
  value3_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value3();
}
inline const ::std::string& Record::value3() const {
  // @@protoc_insertion_point(field_get:Record.value3)
  return value3_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_value3(const ::std::string& value) {
  set_has_value3();
  value3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Record.value3)
}
inline void Record::set_value3(const char* value) {
  set_has_value3();
  value3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Record.value3)
}
inline void Record::set_value3(const void* value, size_t size) {
  set_has_value3();
  value3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Record.value3)
}
inline ::std::string* Record::mutable_value3() {
  set_has_value3();
  // @@protoc_insertion_point(field_mutable:Record.value3)
  return value3_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Record::release_value3() {
  // @@protoc_insertion_point(field_release:Record.value3)
  clear_has_value3();
  return value3_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_allocated_value3(::std::string* value3) {
  if (value3 != NULL) {
    set_has_value3();
  } else {
    clear_has_value3();
  }
  value3_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value3);
  // @@protoc_insertion_point(field_set_allocated:Record.value3)
}

// -------------------------------------------------------------------

// Records

// repeated .Record param = 1;
inline int Records::param_size() const {
  return param_.size();
}
inline void Records::clear_param() {
  param_.Clear();
}
inline const ::Record& Records::param(int index) const {
  // @@protoc_insertion_point(field_get:Records.param)
  return param_.Get(index);
}
inline ::Record* Records::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Records.param)
  return param_.Mutable(index);
}
inline ::Record* Records::add_param() {
  // @@protoc_insertion_point(field_add:Records.param)
  return param_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Record >*
Records::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Records.param)
  return &param_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Record >&
Records::param() const {
  // @@protoc_insertion_point(field_list:Records.param)
  return param_;
}

// -------------------------------------------------------------------

// FileParams

// repeated .Arg attr = 1;
inline int FileParams::attr_size() const {
  return attr_.size();
}
inline void FileParams::clear_attr() {
  attr_.Clear();
}
inline const ::Arg& FileParams::attr(int index) const {
  // @@protoc_insertion_point(field_get:FileParams.attr)
  return attr_.Get(index);
}
inline ::Arg* FileParams::mutable_attr(int index) {
  // @@protoc_insertion_point(field_mutable:FileParams.attr)
  return attr_.Mutable(index);
}
inline ::Arg* FileParams::add_attr() {
  // @@protoc_insertion_point(field_add:FileParams.attr)
  return attr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Arg >*
FileParams::mutable_attr() {
  // @@protoc_insertion_point(field_mutable_list:FileParams.attr)
  return &attr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Arg >&
FileParams::attr() const {
  // @@protoc_insertion_point(field_list:FileParams.attr)
  return attr_;
}

// optional int32 compression = 2 [default = 0];
inline bool FileParams::has_compression() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileParams::set_has_compression() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileParams::clear_has_compression() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileParams::clear_compression() {
  compression_ = 0;
  clear_has_compression();
}
inline ::google::protobuf::int32 FileParams::compression() const {
  // @@protoc_insertion_point(field_get:FileParams.compression)
  return compression_;
}
inline void FileParams::set_compression(::google::protobuf::int32 value) {
  set_has_compression();
  compression_ = value;
  // @@protoc_insertion_point(field_set:FileParams.compression)
}

// -------------------------------------------------------------------

// ConfigData

// required int32 num_workers = 1;
inline bool ConfigData::has_num_workers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigData::set_has_num_workers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigData::clear_has_num_workers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigData::clear_num_workers() {
  num_workers_ = 0;
  clear_has_num_workers();
}
inline ::google::protobuf::int32 ConfigData::num_workers() const {
  // @@protoc_insertion_point(field_get:ConfigData.num_workers)
  return num_workers_;
}
inline void ConfigData::set_num_workers(::google::protobuf::int32 value) {
  set_has_num_workers();
  num_workers_ = value;
  // @@protoc_insertion_point(field_set:ConfigData.num_workers)
}

// required int32 worker_id = 2;
inline bool ConfigData::has_worker_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigData::set_has_worker_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigData::clear_has_worker_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigData::clear_worker_id() {
  worker_id_ = 0;
  clear_has_worker_id();
}
inline ::google::protobuf::int32 ConfigData::worker_id() const {
  // @@protoc_insertion_point(field_get:ConfigData.worker_id)
  return worker_id_;
}
inline void ConfigData::set_worker_id(::google::protobuf::int32 value) {
  set_has_worker_id();
  worker_id_ = value;
  // @@protoc_insertion_point(field_set:ConfigData.worker_id)
}

// required int32 master_id = 3;
inline bool ConfigData::has_master_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigData::set_has_master_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigData::clear_has_master_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigData::clear_master_id() {
  master_id_ = 0;
  clear_has_master_id();
}
inline ::google::protobuf::int32 ConfigData::master_id() const {
  // @@protoc_insertion_point(field_get:ConfigData.master_id)
  return master_id_;
}
inline void ConfigData::set_master_id(::google::protobuf::int32 value) {
  set_has_master_id();
  master_id_ = value;
  // @@protoc_insertion_point(field_set:ConfigData.master_id)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CompressionFormat> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
